# Policy file explained

Say we generate a policy file for a project with the following dependency tree:
```
app.js
└─┬ some-package
  └─┬ entropoetry
    └── bn.js
```

`./lavamoat/node/policy.json`:
```
{
  "resources": {
    "some-package": {
      "globals": {
        "Buffer.from": true
      },
      "packages": {
        "some-package>entropoetry": true
      }
    },
    "some-package>entropoetry": {
      "builtin": {
        "assert": true,
        "buffer.Buffer": true,
        "zlib": true
      },
      "globals": {
        "console": true,
        "process.exitCode": "write",
      },
      "packages": {
        "some-package>entropoetry>bn.js": true
      }
    },
    "some-package>entropoetry>bn.js": {
      "builtin": {
        "buffer.Buffer": true
      },
      "globals": {
        "Buffer": true
      }
    }
  }
}
```

## Fields
### resources 

All packages in your dependency graph accessible via `require()`.  
Note that each resource is not represented just by the name of the package, but by a full dependency tree path to it. LavaMoat picks the shortest dependency path for each entry in resources to prevent a malicious package crafted to be represented with the same name but not fetched from npm to hijack permissions.


### packages and builtin

All packages accessible by the dependency. In this example, `some-package` has access to `entropoetry`.This means that `some-package` can `require('entropoetry')`.

`entropoetry` can also `require('assert')` - a built-in module of Node.js.


### globals
 All platform APIs and global variables accessible by the dependency. In this example,`entropoetry` has access to `console` and it can write to process.exitCode. Global access is read-only, unless defined by the `write` value.

Write access is represented by a string to make it stand out when inspecting the policy file.

## Limiting access to fields of powerful objects

You may have noticed the dot notation in keys within globals, packages and builtins. It can be used to limit the reference the package gets to just a subset of fields on the object.

`"Buffer.from": true` means the `Buffer` global reference will exist in the package's scope but will only contain the `from` field and no other fields.  
Same goes for `"buffer.Buffer": true` in builtins - when the package does `const buffer = require('buffer')` it will get an object with just one reference to `Buffer` constructor.

LavaMoat can often generate precise lists of fields used by the package. You can narrow them down further if need be by creating a `policy-override.json` file next to the `policy.json`.

# Using policy-override to expand or limit access

## Adding access where LavaMoat's policy was too strict

Policy files are generated by statically analyzing the source of packages and finding out which powerful references they seem to be using. It's impossible to detect it 100% correctly because there are JavaScript constructs that can't be detected without running the code.  
If such missing permissions are identified, it's best to doublecheck they're expected to be there and then add them to the policy-override file.

Example:  
Allow `entropoetry` access to the global `URL` class and expand access to the entire `buffer` builtin on top of the generated policy above.

`./lavamoat/node/policy-override.json`:
```
{
  "resources": {
    "some-package>entropoetry": {
      "globals": {
        "URL": true,
      }
    },
    "some-package>entropoetry>bn.js": {
      "builtin": {
        "buffer": true
      }
    }
  }
}
```

## Limiting access

If LavaMoat's static analysis finds references used in a package, but in a functionality that's not called in your application it's reasonable to want them denied. 

Example:  
- Forbid requiring of `assert` by `entropoetry`
- Deny access to `console` with the exception of `console.log`

`./lavamoat/node/policy-override.json`:
```
{
  "resources": {
    "some-package>entropoetry": {
      "builtin": {
        "assert": false
      },
      "globals": {
        "console": false,
        "console.log": true
      }
    }
  }
}
```

### ⚠️ Unsupported deny-list style policy

> **Warning**  
> Explicitly allowing access to an entire item and then attempting to narrow it down is not supported. The order of items in the JSON file should not matter.
> As a result the following will not work as intuitively expected:

```
/*** broken example ***/
  "globals": {
    "a": true,
    "a.b": false
  }
/*** broken example ***/
```    

`a.b` will remain accessible since `a` was declared as accessible in its entirety.

To properly deny access to `a.b` while allowing access to other fields of `a` you'd need an allow-list style policy like this:
```
  "globals": {
    "a.c": true,
    "a.d": true
  }
```

----

More specifically, the deepest chain of properties needs to point to an allowed reference and skipping all-but-necessary access on higher levels is possible, so the following will work and allow `a.z` and `a.b.c` but not `a.b.y`

```
  "globals": {
    "a": true,
    "a.b": false,
    "a.b.c":true
  }
```

See packages/core/test/globals.js for reference

You should not need this level of complexity often and LavaMoat will not generate negative entries for you to review.